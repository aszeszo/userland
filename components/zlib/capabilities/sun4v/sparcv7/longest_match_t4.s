!
! This file was generated by a compiler that is currently not part of the CBE
! as the CBE compiler does not generate code for the T4 architecture. If
! such a compiler (e.g. the Oracle Studio 12.3) becomes part of the CBE
! the longest_match.o file can simply be comp[iled from longest_match.c
! as for the 32-bit version, no modifications were made.
!

	.section	".text",#alloc,#execinstr,#progbits
	.file	"longest_match.c"

	.section	".bss",#alloc,#write,#nobits

Bbss.bss:

	.section	".data",#alloc,#write,#progbits

Ddata.data:

	.section	".rodata",#alloc,#progbits
!
! CONSTANT POOL
!

Drodata.rodata:
	.global	deflate_lm_copyright
!
! CONSTANT POOL
!
	.global deflate_lm_copyright

deflate_lm_copyright:
	.byte	32
	.byte	100
	.byte	101
	.byte	102
	.byte	108
	.byte	97
	.byte	116
	.byte	101
	.byte	47
	.byte	108
	.byte	111
	.byte	110
	.byte	103
	.byte	101
	.byte	115
	.byte	116
	.byte	95
	.byte	109
	.byte	97
	.byte	116
	.byte	99
	.byte	104
	.byte	32
	.byte	49
	.byte	46
	.byte	50
	.byte	46
	.byte	51
	.byte	32
	.byte	67
	.byte	111
	.byte	112
	.byte	121
	.byte	114
	.byte	105
	.byte	103
	.byte	104
	.byte	116
	.byte	32
	.byte	49
	.byte	57
	.byte	57
	.byte	53
	.byte	45
	.byte	50
	.byte	48
	.byte	48
	.byte	53
	.byte	32
	.byte	74
	.byte	101
	.byte	97
	.byte	110
	.byte	45
	.byte	108
	.byte	111
	.byte	117
	.byte	112
	.byte	32
	.byte	71
	.byte	97
	.byte	105
	.byte	108
	.byte	108
	.byte	121
	.byte	32
	.skip	1
	.type	deflate_lm_copyright,#object
	.size	deflate_lm_copyright,67

	.section	".tbss",#alloc,#write,#tls,#nobits

Ttbss.bss:

	.section	".tdata",#alloc,#write,#tls,#progbits

Ttdata.data:

	.section	".text",#alloc,#execinstr,#progbits
/* 000000	   0 */		.align	4
! FILE longest_match.c

!    1		      !/* deflate.c -- compress data using the deflation algorithm
!    2		      ! * Copyright (C) 1995-2005 Jean-loup Gailly.
!    3		      ! * For conditions of distribution and use, see copyright notice in zlib.h
!    4		      ! */
!    6		      !/*
!    7		      ! * This file contains the longest_match() function cut out from the original
!    8		      ! * deflate.c file - this was necessary so that the compiler do not inline
!    9		      ! * this function and so architecture-specific versions of it may be built
!   10		      ! * that can use the linker's capabilities-based linking feature to produce
!   11		      ! * the best executable for all platforms.
!   12		      ! */
!   14		      !/* @(#) $Id$ */
!   16		      !#include "deflate.h"
!   18		      !const char deflate_lm_copyright[] =
!   19		      !   " deflate/longest_match 1.2.3 Copyright 1995-2005 Jean-loup Gailly ";
!   20		      !/*
!   21		      !  If you use the zlib library in a product, an acknowledgment is welcome
!   22		      !  in the documentation of your product. If for some reason you cannot
!   23		      !  include such an acknowledgment, I would appreciate that you keep this
!   24		      !  copyright string in the executable of your product.
!   25		      ! */
!   27		      !#define NIL 0
!   29		      !#ifndef FASTEST
!   30		      !#ifdef ASMV
!   31		      !      void match_init OF((void)); /* asm code initialization */
!   32		      !      uInt longest_match  OF((deflate_state *s, IPos cur_match));
!   33		      !#else
!   34		      !uInt longest_match  OF((deflate_state *s, IPos cur_match));
!   35		      !#endif
!   37		      !/* ===========================================================================
!   38		      ! * Set match_start to the longest match starting at the given string and
!   39		      ! * return its length. Matches shorter or equal to prev_length are discarded,
!   40		      ! * in which case the result is equal to prev_length and match_start is
!   41		      ! * garbage.
!   42		      ! * IN assertions: cur_match is the head of the hash chain for the current
!   43		      ! *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
!   44		      ! * OUT assertion: the match length is not greater than s->lookahead.
!   45		      ! */
!   46		      !#ifndef ASMV
!   47		      !/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
!   48		      ! * match.S. The code will be functionally equivalent.
!   49		      ! */
!   50		      !uInt longest_match(s, cur_match)
!   51		      !    deflate_state *s;
!   52		      !    IPos cur_match;                             /* current match */
!   53		      !{

!
! SUBROUTINE longest_match
!
! OFFSET    SOURCE LINE	LABEL	INSTRUCTION

                       	.global longest_match
                       

			longest_match:

! Registers live out of longest_match: 
! g2 o1 sp l1 l2 l4 l5 l6 i0 i1 i2 i3 i4 fp gsr 
! 
		                       

			.L900000109:
/* 000000	  53 */		save	%sp,-96,%sp

!   54		      !    unsigned chain_length = s->max_chain_length;/* max hash chain length */
!   55		      !    register Bytef *scan = s->window + s->strstart; /* current string */

/* 0x0004	  55 */		ld	[%i0+108],%l4
/* 0x0008	     */		ld	[%i0+56],%l5

!   56		      !    register Bytef *match;                       /* matched string */
!   57		      !    register int len;                           /* length of current match */
!   58		      !    int best_len = s->prev_length;              /* best match length so far */
!   59		      !    int nice_match = s->nice_match;             /* stop if match long enough */
!   60		      !    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
!   61		      !        s->strstart - (IPos)MAX_DIST(s) : NIL;

/* 0x000c	  61 */		mov	0,%l6
/* 0x0010	     */		ld	[%i0+44],%i5
/* 0x0014	  58 */		ld	[%i0+120],%i2
/* 0x0018	  54 */		ld	[%i0+124],%o1
/* 0x001c	  59 */		ld	[%i0+144],%g2
/* 0x0020	  93 */		ld	[%i0+116],%i3
/* 0x0024	  55 */		add	%l5,%l4,%i4
/* 0x0028	  87 */		ld	[%i0+140],%l1
/* 0x002c	  61 */		add	%i5,-262,%l3
/* 0x0030	  77 */		add	%i4,%i2,%l2
/* 0x0034	  61 */		cwbleu	%l4,%l3,.L77000163
                       
! predecessor blocks: .L900000109

			.L77000159:
/* 0x0038	  61 */		sub	%l4,%l3,%l6

! Registers live out of .L77000159: 
! g2 o1 sp l1 l2 l5 l6 i0 i1 i2 i3 i4 fp gsr 
! 
		
!   62		      !    /* Stop when cur_match becomes <= limit. To simplify the code,
!   63		      !     * we prevent matches with the string of window index 0.
!   64		      !     */
!   65		      !    Posf *prev = s->prev;
!   66		      !    uInt wmask = s->w_mask;
!   68		      !#ifdef UNALIGNED_OK
!   69		      !    /* Compare two bytes at a time. Note: this is not always beneficial.
!   70		      !     * Try with and without -DUNALIGNED_OK to check.
!   71		      !     */
!   72		      !    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
!   73		      !    register ush scan_start = *(ushf*)scan;
!   74		      !    register ush scan_end   = *(ushf*)(scan+best_len-1);
!   75		      !#else
!   76		      !    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
!   77		      !    register Byte scan_end1  = scan[best_len-1];

                       
! predecessor blocks: .L77000159 .L900000109

			.L77000163:
/* 0x003c	  77 */		ldub	[%l2-1],%l4

!   78		      !    register Byte scan_end   = scan[best_len];
!   79		      !#endif
!   81		      !    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
!   82		      !     * It is easy to get rid of this optimization if necessary.
!   83		      !     */
!   84		      !    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
!   86		      !    /* Do not waste too much time if we already have a good match: */
!   87		      !    if (s->prev_length >= s->good_match) {

/* 0x0040	  87 */		cmp	%i2,%l1
/* 0x0044	  78 */		ldub	[%i4+%i2],%l3
/* 0x0048	  76 */		add	%i4,258,%l7
/* 0x004c	  66 */		ld	[%i0+52],%l1
/* 0x0050	  65 */		ld	[%i0+64],%l2
/* 0x0054	  87 */		bcs,pn	%icc,.L77000167
/* 0x0058	  93 */		cmp	%g2,%i3

! Registers live out of .L77000163: 
! g2 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		
!   88		      !        chain_length >>= 2;

                       
! predecessor blocks: .L77000163

			.L77000165:
/* 0x005c	  88 */		srl	%o1,2,%o1

! Registers live out of .L77000165: 
! g2 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		
!   89		      !    }
!   90		      !    /* Do not look for matches beyond the end of the input. This is necessary
!   91		      !     * to make deflate deterministic.
!   92		      !     */
!   93		      !    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

                       
! predecessor blocks: .L77000163 .L77000165

			.L77000167:
/* 0x0060	  93 */		movgu	%icc,%i3,%g2

!   95		      !    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
!   97		      !    do {
!   98		      !        Assert(cur_match < s->strstart, "no future");
!   99		      !        match = s->window + cur_match;

/* 0x0064	  99 */		add	%i1,%l5,%g3

! Registers live out of .L77000167: 
! g2 g3 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		
!  101		      !        /* Skip to next match if the match length cannot increase
!  102		      !         * or if the match length is less than 2.  Note that the checks below
!  103		      !         * for insufficient lookahead only occur occasionally for performance
!  104		      !         * reasons.  Therefore uninitialized memory will be accessed, and
!  105		      !         * conditional jumps will be made that depend on those values.
!  106		      !         * However the length of the match is limited to the lookahead, so
!  107		      !         * the output of deflate is not affected by the uninitialized values.
!  108		      !         */
!  109		      !#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
!  110		      !        /* This code assumes sizeof(unsigned short) == 2. Do not use
!  111		      !         * UNALIGNED_OK if your compiler uses a different size.
!  112		      !         */
!  113		      !        if (*(ushf*)(match+best_len-1) != scan_end ||
!  114		      !            *(ushf*)match != scan_start) continue;
!  116		      !        /* It is not necessary to compare scan[2] and match[2] since they are
!  117		      !         * always equal when the other bytes match, given that the hash keys
!  118		      !         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
!  119		      !         * strstart+3, +5, ... up to strstart+257. We check for insufficient
!  120		      !         * lookahead only every 4th comparison; the 128th check will be made
!  121		      !         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
!  122		      !         * necessary to put more guard bytes at the end of the window, or
!  123		      !         * to check more often for insufficient lookahead.
!  124		      !         */
!  125		      !        Assert(scan[2] == match[2], "scan[2]?");
!  126		      !        scan++, match++;
!  127		      !        do {
!  128		      !        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
!  129		      !                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
!  130		      !                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
!  131		      !                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
!  132		      !                 scan < strend);
!  133		      !        /* The funny "do {}" generates better code on most compilers */
!  135		      !        /* Here, scan <= window+strstart+257 */
!  136		      !        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
!  137		      !        if (*scan == *match) scan++;
!  139		      !        len = (MAX_MATCH - 1) - (int)(strend-scan);
!  140		      !        scan = strend - (MAX_MATCH-1);
!  142		      !#else /* UNALIGNED_OK */
!  144		      !        if (match[best_len]   != scan_end  ||
!  145		      !            match[best_len-1] != scan_end1 ||
!  146		      !            *match            != *scan     ||
!  147		      !            *++match          != scan[1])      continue;

                       
! predecessor blocks: .L77000167 .L77000219

			.L900000107:
/* 0x0068	 147 */		ldub	[%g3+%i2],%o3
/* 0x006c	     */		cwbne	%o3,%l3,.L77000217

! Registers live out of .L900000107: 
! g2 g3 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		                       
! predecessor blocks: .L900000107

			.L77000175:
/* 0x0070	 147 */		add	%g3,%i2,%g4
/* 0x0074	     */		ldub	[%g4-1],%o4
/* 0x0078	     */		cwbne	%o4,%l4,.L77000217

! Registers live out of .L77000175: 
! g2 g3 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		                       
! predecessor blocks: .L77000175

			.L77000177:
/* 0x007c	 147 */		ldub	[%l5+%i1],%o5
/* 0x0080	     */		ldub	[%i4],%o7
/* 0x0084	     */		cwbne	%o5,%o7,.L77000217

! Registers live out of .L77000177: 
! g2 g3 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		                       
! predecessor blocks: .L77000177

			.L77000179:
/* 0x0088	 147 */		ldub	[%i4+1],%i5
/* 0x008c	     */		ldub	[%g3+1],%l0
/* 0x0090	     */		cwbne	%l0,%i5,.L77000217

! Registers live out of .L77000179: 
! g2 g3 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		
!  149		      !        /* The check at best_len-1 can be removed because it will be made
!  150		      !         * again later. (This heuristic is not always a win.)
!  151		      !         * It is not necessary to compare scan[2] and match[2] since they
!  152		      !         * are always equal when the other bytes match, given that
!  153		      !         * the hash keys are equal and that HASH_BITS >= 8.
!  154		      !         */
!  155		      !        scan += 2, match++;

                       
! predecessor blocks: .L77000179

			.L77000185:
/* 0x0094	 155 */		add	%i4,2,%g4
/* 0x0098	     */		add	%g3,2,%g3

! Registers live out of .L77000185: 
! g2 g3 g4 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		
!  156		      !        Assert(*scan == *match, "match[2]?");
!  158		      !        /* We check for insufficient lookahead only every 8th comparison;
!  159		      !         * the 256th check will be made at strstart+258.
!  160		      !         */
!  161		      !        do {
!  162		      !        } while (*++scan == *++match && *++scan == *++match &&
!  163		      !                 *++scan == *++match && *++scan == *++match &&
!  164		      !                 *++scan == *++match && *++scan == *++match &&
!  165		      !                 *++scan == *++match && *++scan == *++match &&
!  166		      !                 scan < strend);

                       
! predecessor blocks: .L77000185 .L77000203

			.L77000187:
/* 0x009c	 166 */		ldub	[%g4+1],%g1
/* 0x00a0	     */		add	%g4,1,%g4
/* 0x00a4	     */		ldub	[%g3+1],%g5
/* 0x00a8	     */		cwbne	%g1,%g5,.L77000207

! Registers live out of .L77000187: 
! g2 g3 g4 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		                       
! predecessor blocks: .L77000187

			.L77000189:
/* 0x00ac	 166 */		ldub	[%g4+1],%o0
/* 0x00b0	     */		add	%g4,1,%g4
/* 0x00b4	     */		ldub	[%g3+2],%o2
/* 0x00b8	     */		cwbne	%o0,%o2,.L77000207

! Registers live out of .L77000189: 
! g2 g3 g4 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		                       
! predecessor blocks: .L77000189

			.L77000191:
/* 0x00bc	 166 */		ldub	[%g4+1],%o3
/* 0x00c0	     */		add	%g4,1,%g4
/* 0x00c4	     */		ldub	[%g3+3],%o4
/* 0x00c8	     */		cwbne	%o3,%o4,.L77000207

! Registers live out of .L77000191: 
! g2 g3 g4 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		                       
! predecessor blocks: .L77000191

			.L77000193:
/* 0x00cc	 166 */		ldub	[%g4+1],%o5
/* 0x00d0	     */		add	%g4,1,%g4
/* 0x00d4	     */		ldub	[%g3+4],%o7
/* 0x00d8	     */		cwbne	%o5,%o7,.L77000207

! Registers live out of .L77000193: 
! g2 g3 g4 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		                       
! predecessor blocks: .L77000193

			.L77000195:
/* 0x00dc	 166 */		ldub	[%g4+1],%l0
/* 0x00e0	     */		add	%g4,1,%g4
/* 0x00e4	     */		ldub	[%g3+5],%i5
/* 0x00e8	     */		cwbne	%l0,%i5,.L77000207

! Registers live out of .L77000195: 
! g2 g3 g4 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		                       
! predecessor blocks: .L77000195

			.L77000197:
/* 0x00ec	 166 */		ldub	[%g4+1],%g1
/* 0x00f0	     */		add	%g4,1,%g4
/* 0x00f4	     */		ldub	[%g3+6],%g5
/* 0x00f8	     */		cwbne	%g1,%g5,.L77000207

! Registers live out of .L77000197: 
! g2 g3 g4 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		                       
! predecessor blocks: .L77000197

			.L77000199:
/* 0x00fc	 166 */		ldub	[%g4+1],%o0
/* 0x0100	     */		add	%g4,1,%g4
/* 0x0104	     */		ldub	[%g3+7],%o2
/* 0x0108	     */		cwbne	%o0,%o2,.L77000207

! Registers live out of .L77000199: 
! g2 g3 g4 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		                       
! predecessor blocks: .L77000199

			.L77000201:
/* 0x010c	 166 */		ldub	[%g4+1],%o3
/* 0x0110	     */		add	%g4,1,%g4
/* 0x0114	     */		ldub	[%g3+8],%o4
/* 0x0118	     */		add	%g3,8,%g3
/* 0x011c	     */		cwbne	%o3,%o4,.L77000207
/* 0x0120	     */		nop

! Registers live out of .L77000201: 
! g2 g3 g4 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		                       
! predecessor blocks: .L77000201

			.L77000203:
/* 0x0124	 166 */		cwbcs	%g4,%l7,.L77000187

! Registers live out of .L77000203: 
! g2 g3 g4 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		
!  168		      !        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
!  170		      !        len = MAX_MATCH - (int)(strend - scan);

                       
! predecessor blocks: .L77000187 .L77000189 .L77000191 .L77000193 .L77000195 .L77000197 .L77000199 .L77000201 .L77000203

			.L77000207:
/* 0x0128	 170 */		sub	%g4,%l7,%o7
/* 0x012c	     */		add	%o7,258,%o5

!  171		      !        scan = strend - MAX_MATCH;
!  173		      !#endif /* UNALIGNED_OK */
!  175		      !        if (len > best_len) {

/* 0x0130	 175 */		cwble	%o5,%i2,.L77000217

! Registers live out of .L77000207: 
! g2 o1 o5 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		
!  176		      !            s->match_start = cur_match;

                       
! predecessor blocks: .L77000207

			.L77000209:
/* 0x0134	 176 */		st	%i1,[%i0+112]

!  177		      !            best_len = len;

/* 0x0138	 177 */		mov	%o5,%i2

!  178		      !            if (len >= nice_match) break;

/* 0x013c	 178 */		cwbge	%o5,%g2,.L77000225

! Registers live out of .L77000209: 
! g2 o1 o5 sp l1 l2 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		
!  179		      !#ifdef UNALIGNED_OK
!  180		      !            scan_end = *(ushf*)(scan+best_len-1);
!  181		      !#else
!  182		      !            scan_end1  = scan[best_len-1];

                       
! predecessor blocks: .L77000209

			.L77000213:
/* 0x0140	 182 */		add	%i4,%o5,%l4

!  183		      !            scan_end   = scan[best_len];

/* 0x0144	 183 */		ldub	[%i4+%o5],%l3
/* 0x0148	 182 */		ldub	[%l4-1],%l4

! Registers live out of .L77000213: 
! g2 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		
!  184		      !#endif
!  185		      !        }
!  186		      !    } while ((cur_match = prev[cur_match & wmask]) > limit
!  187		      !             && --chain_length != 0);

                       
! predecessor blocks: .L77000175 .L77000177 .L77000179 .L77000207 .L77000213 .L900000107

			.L77000217:
/* 0x014c	 187 */		and	%i1,%l1,%i1
/* 0x0150	     */		sll	%i1,1,%l0
/* 0x0154	     */		lduh	[%l0+%l2],%i1
/* 0x0158	     */		cwbleu	%i1,%l6,.L77000225

! Registers live out of .L77000217: 
! g2 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		                       
! predecessor blocks: .L77000217

			.L77000219:
/* 0x015c	 187 */		addcc	%o1,-1,%o1
/* 0x0160	     */		bne,pt	%icc,.L900000107
/* 0x0164	  99 */		add	%i1,%l5,%g3

! Registers live out of .L77000219: 
! g2 g3 o1 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i3 i4 fp gsr 
! 
		
!  189		      !    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;

                       
! predecessor blocks: .L77000209 .L77000217 .L77000219

			.L77000225:
/* 0x0168	 189 */		mov	%i3,%i0
/* 0x016c	     */		cmp	%i2,%i3
/* 0x0170	     */		movleu	%icc,%i2,%i0

!  190		      !    return s->lookahead;

/* 0x0174	 190 */		return	%i7+8	! Result =  %i0
/* 0x0178	     */		nop
/* 0x017c	   0 */		.type	longest_match,#function
/* 0x017c	   0 */		.size	longest_match,(.-longest_match)
                       

			.L900000110:

	.section	".text",#alloc,#execinstr,#progbits
                       

			.L900000112:

	.section	".annotate",#progbits
/* 000000	   0 */		.asciz	"anotate"
/* 0x0008	   0 */		.half	6,0
/* 0x000c	   0 */		.word	28
/* 0x0010	   0 */		.half	0,8
/* 0x0014	   0 */		.word	(.L900000112-0x17c)
/* 0x0018	   0 */		.word	380
/* 0x001c	   0 */		.half	1,12
/* 0x0020	   0 */		.word	.L900000109
/* 0x0024	   0 */		.word	(.L900000110-.L900000109)
/* 0x0028	   0 */		.word	1577088

! Begin Disassembling Debug Info
!  Begin sdCreateSection : .debug_info
!  Section Info: link_name/strtab=, entsize=0x1, adralign=0x1, flags=0x0
!  Section Data Blocks:
!   reloc[0]: knd=2, off=6, siz=4, lab1=.debug_abbrev, lab2=, loff=0
!   reloc[1]: knd=2, off=286, siz=4, lab1=.debug_line, lab2=, loff=0
	.section ".debug_info"
	.byte 0x00,0x00,0x01,0x1f,0x00,0x02
	.uaword %section_symbol(".debug_abbrev")
	.byte 0x04,0x01
	.ascii "longest_match.c\0"
	.byte 0x0c
	.ascii "/builds/frakoczi/userland_s11u1/zlib-t4/components/zlib/build/sparcv7\0"
	.ascii " /ws/onnv-tools/SUNWspro/solarisstudio12.3/prod/bin/cc -xtarget=T4 -xarch=sparc4 -xchip=T4 -xO5 -S  longest_match.c\0"
	.ascii "Xa;O;R=Sun C 5.12 SunOS_sparc 2011/11/16;backend;raw;cd;\0"
	.ascii "DBG_GEN 5.3.3\0"
	.uaword %section_symbol(".debug_line")
	.byte 0x00
!  End sdCreateSection
!  Begin sdCreateSection : .debug_line
!  Section Info: link_name/strtab=, entsize=0x1, adralign=0x1, flags=0x0
!  Section Data Blocks:
	.section ".debug_line"
	.byte 0x00,0x00,0x00,0x29,0x00,0x02,0x00,0x00
	.byte 0x00,0x23,0x04,0x00,0xff,0x04,0x0a,0x00
	.byte 0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x01
	.byte 0x00,0x6c,0x6f,0x6e,0x67,0x65,0x73,0x74
	.byte 0x5f,0x6d,0x61,0x74,0x63,0x68,0x2e,0x63
	.byte 0x00,0x00,0x00,0x00,0x00
!  End sdCreateSection
!  Begin sdCreateSection : .debug_abbrev
!  Section Info: link_name/strtab=, entsize=0x1, adralign=0x1, flags=0x0
!  Section Data Blocks:
	.section ".debug_abbrev"
	.byte 0x01,0x11,0x00,0x03,0x08,0x13,0x0b,0x1b
	.byte 0x08,0x85,0x44,0x08,0x87,0x44,0x08,0x25
	.byte 0x08,0x10,0x06,0x00,0x00,0x00
!  End sdCreateSection

! End Disassembling Debug Info

! Begin Disassembling Ident
	.ident	"cg: Sun Compiler Common 12.3 SunOS_sparc 2011/11/16"	! (NO SOURCE LINE)
	.ident	"acomp: Sun C 5.12 SunOS_sparc 2011/11/16"	! (/tmp/acomp.1337176051.3981.02.sd:84)
	.ident	"iropt: Sun Compiler Common 12.3 SunOS_sparc 2011/11/16"	! (/tmp/acomp.1337176051.3981.02.sd:85)
	.ident	"cg: Sun Compiler Common 12.3 SunOS_sparc 2011/11/16"	! (NO SOURCE LINE)
! End Disassembling Ident
